mod helpers;
use std::cmp;

use ::function_name::named;

fn main() {
    problem_1();
    problem_2();
    problem_3();
    problem_4();
    problem_5();
    problem_6();
    problem_7();
    problem_8();
    problem_9();
    problem_10();
    problem_11();
}

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of $3$ or $5$ below $1000$.
#[named]
fn problem_1() {
    let mut sum = 0;

    for i in 1..1000 {
        if i % 3 == 0 || i % 5 == 0 {
            sum += i;
        }
    }

    println!(" {} answer: {}", function_name!(), sum);
}

// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
#[named]
fn problem_2() {
    let mut sum = 0;
    let mut first = 1;
    let mut seccond = 1;
    let mut third = 0;

    while third < 4000000 {
        third = first + seccond;

        if third % 2 == 0 {
            sum += third;
        }

        first = seccond;
        seccond = third;
    }

    println!(" {} answer: {}", function_name!(), sum);
}

// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143
#[named]
fn problem_3() {
    let num: i64 = 600851475143i64;

    let sqrt_num = (num as f64).sqrt() as i64;
    let mut largest_factor = 0;

    for i in (2..=sqrt_num).rev() {
        if num % i == 0 && helpers::is_prime(i as u64) {
            largest_factor = i;
            break;
        }
    }

    println!(
        " {} answer: {}",
        function_name!(),
        largest_factor
    );
}

// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.
// Find the largest palindrome made from the product of two 3-digit numbers.
#[named]
fn problem_4() {
    let mut largest = 0;
    for i in (100..=999).rev() {
        for j in (100..=i).rev() {
            let product = i * j;
            if helpers::is_palindrome(product) {
                if product > largest {
                    largest = product;
                }
            }
        }
    }
    println!(" {} answer: {}", function_name!(), largest);
}

// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible
// divisible with no remainder by all of the numbers from 1 to 20
#[named]
fn problem_5() {
    let mut answer = 20;
    loop {
        if answer % 20 == 0
            && answer % 19 == 0
            && answer % 18 == 0
            && answer % 17 == 0
            && answer % 16 == 0
            && answer % 15 == 0
            && answer % 14 == 0
            && answer % 13 == 0
            && answer % 12 == 0
            && answer % 11 == 0
            && answer % 10 == 0
            && answer % 9 == 0
            && answer % 8 == 0
            && answer % 7 == 0
            && answer % 6 == 0
            && answer % 5 == 0
            && answer % 4 == 0
            && answer % 3 == 0
            && answer % 2 == 0
        {
            break;
        }
        answer += 1;
    }
    println!(" {} answer: {}", function_name!(), answer);
}

// The sum of the squares of the first ten natural numbers is 385
// The square of the sum of the first ten natural numbers is 3025
// Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 2640
// Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
#[named]
fn problem_6() {
    let mut sum_of_squares = 0;
    for i in 1..=100 {
        sum_of_squares += i * i;
    }

    let square_of_sums = (100 * 101 / 2) * (100 * 101 / 2);
    let difference = square_of_sums - sum_of_squares;

    println!(
        " {} answer: {}",
        function_name!(),
        difference
    );
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, 13
// we can see that the 6th prime is 13
// What is the 10001st prime number?
#[named]
fn problem_7() {
    let mut count = 1;
    let mut num = 1;

    loop {
        if helpers::is_prime(num) {
            count += 1;
        }

        if count == 10001 {
            break;
        }

        num += 2;
    }

    println!(" {} answer: {}", function_name!(), num);
}

// The four adjacent digits in the 1000-digit number that have the greatest product are 9 x 9 x 8 x 9 = 5832
// Find the thirteen adjacent digits in the 1000-digit number
// that have the greatest product. What is the value of the product?
#[named]
fn problem_8() {
    let number = "73167176531330624919225119674426574742355349194934\
    96983520312774506326239578318016984801869478851843\
    85861560789112949495459501737958331952853208805511\
    12540698747158523863050715693290963295227443043557\
    66896648950445244523161731856403098711121722383113\
    62229893423380308135336276614282806444486645238749\
    30358907296290491560440772390713810515859307960866\
    70172427121883998797908792274921901699720888093776\
    65727333001053367881220235421809751254540594752243\
    52584907711670556013604839586446706324415722155397\
    53697817977846174064955149290862569321978468622482\
    83972241375657056057490261407972968652414535100474\
    82166370484403199890008895243450658541227588666881\
    16427171479924442928230863465674813919123162824586\
    17866458359124566529476545682848912883142607690042\
    24219022671055626321111109370544217506941658960408\
    07198403850962455444362981230987879927244284909188\
    84580156166097919133875499200524063689912560717606\
    05886116467109405077541002256983155200055935729725\
    71636269561882670428252483600823257530420752963450";

    let mut max_product = 0;
    let number_len = number.len();
    for i in 0..(number_len - 12) {
        let next_13_chars: String = number.chars().skip(i).take(13).collect();
        let numbers: Vec<i64> = next_13_chars
            .chars()
            .map(|c| c.to_digit(10).unwrap() as i64)
            .collect();

        if numbers.contains(&0) {
            continue;
        }

        let product: i64 = numbers.iter().product();

        if max_product < product {
            max_product = product;
        }
    }

    println!(
        " {} answer: {}",
        function_name!(),
        max_product
    );
}

// A Pythagorean triplet is a set of three natural numbers, a b c, for which,
// a^2 + b^2 = c^2
// For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2
// There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc
#[named]
fn problem_9() {
    let mut answer = 0;
    let combination_iter = helpers::generate_combinations_of_three(1000);
    for c in combination_iter {
        let a = c.0;
        let b = c.1;
        let c = c.2;

        if a >= b || b >= c {
            continue;
        }

        let sum = a + b + c;
        if sum != 1000 {
            continue;
        }

        let ab_sq = a * a + b * b;
        let c_sq = c * c;
        if ab_sq != c_sq {
            continue;
        }

        answer = a * b * c;
    }

    println!(" {} answer: {}", function_name!(), answer);
}

// Find the sum of all the primes below two million
#[named]
fn problem_10() {
    let primes = helpers::sieve_of_eratosthenes(2_000_000);
    let mut sum: u64 = primes.into_iter().sum();

    println!(" {} answer: {}", function_name!(), sum);
}

#[named]
pub fn problem_11() {
    let grid = [
        08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08, 49, 49, 99,
        40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00, 81, 49, 31, 73, 55, 79,
        14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65, 52, 70, 95, 23, 04, 60, 11, 42, 69,
        24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91, 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54,
        22, 40, 40, 28, 66, 33, 13, 80, 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84,
        20, 35, 17, 12, 50, 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38,
        64, 70, 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21, 24,
        55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72, 21, 36, 23, 09,
        75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95, 78, 17, 53, 28, 22, 75, 31,
        67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92, 16, 39, 05, 42, 96, 35, 31, 47, 55, 58,
        88, 24, 00, 17, 54, 24, 36, 29, 85, 57, 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44,
        60, 21, 58, 51, 54, 17, 58, 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77,
        04, 89, 55, 40, 04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98,
        66, 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69, 04, 42,
        16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36, 20, 69, 36, 41, 72,
        30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16, 20, 73, 35, 29, 78, 31, 90, 01,
        74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54, 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33,
        48, 61, 43, 52, 01, 89, 19, 67, 48,
    ];

    let mut matrix: [[i32; 20]; 20] = [[0; 20]; 20];

    for i in 0..20 {
        for j in 0..20 {
            matrix[i][j] = grid[i * 20 + j];
        }
    }

    let mut largest_product = 0;

    for row in 0..20 {
        for col in 0..20 {
            let row_0 = row;

            let mut row_1 = row + 1;
            let mut row_2 = row + 2;
            let mut row_3 = row + 3;

            let col_0 = col;
            let col_1 = col + 1;
            let col_2 = col + 2;
            let col_3 = col + 3;

            if row_3 < 20 && col_3 < 20 {
                let num_0 = matrix[row_0][col_0];
                let num_1 = matrix[row_1][col_1];
                let num_2 = matrix[row_2][col_2];
                let num_3 = matrix[row_3][col_3];

                let product = num_0 * num_1 * num_2 * num_3;

                if product > largest_product {
                    largest_product = product;
                }
            }

            let r1 = row as i32 - 1;
            let r2 = row as i32 - 2;
            let r3 = row as i32 - 3;

            if col_3 < 20 && r1 >= 0 && r2 >= 0 && r3 > 0 {
                row_1 = row - 1;
                row_2 = row - 2;
                row_3 = row - 3;

                let num_0 = matrix[row_0][col_0];
                let num_1 = matrix[row_1][col_1];
                let num_2 = matrix[row_2][col_2];
                let num_3 = matrix[row_3][col_3];

                let product = num_0 * num_1 * num_2 * num_3;

                if product > largest_product {
                    largest_product = product;
                }
            }
        }
    }

    println!(" {} answer: {}", function_name!(), largest_product);
}

#[named]
pub fn problem_12() {

}